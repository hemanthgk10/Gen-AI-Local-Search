---
category: Security
checkTool: checkov
checkType: Kubernetes
compliance:
  - CIS
description: |-
    Kubernetes is an open source platform for orchestrating containers. A container is a technology that lets you bundle and isolate applications with their entire runtime environment so that it’s easy to move the contained application between stages (development, production, etc.) and environments (on-premise, public cloud, private cloud, hybrid cloud, or multicloud) while retaining full functionality.

    The Kubernetes API is the front end of the Kubernetes control plane and is how users interact with their Kubernetes cluster. The API (application programming interface) server determines if a request is valid and then processes it. These Kubernetes API server validates and configures data for the api objects which include pods, services, replicationcontrollers, and others.

    Users access the Kubernetes API using kubectl, client libraries, or by making REST requests. Both human users and Kubernetes service accounts can be authorized for API access. When a request reaches the API, it goes through several stages such as
      * Authentication
      * Authorization
      * Admission Control

    Kubernetes API server can actually serve requests on 2 ports:
      * localhost port which is insecure.
      * Secure port which is recommended.

    In order to use `secure port`, we need to set cert with --tls-cert-file and key with --tls-private-key-file flag.
extra:
  entity: containers
  type: resource
guidelines: |-
    #### Description
    Kubernetes is an open source platform for orchestrating containers. A container is a technology that lets you bundle and isolate applications with their entire runtime environment so that it’s easy to move the contained application between stages (development, production, etc.) and environments (on-premise, public cloud, private cloud, hybrid cloud, or multicloud) while retaining full functionality.

    The Kubernetes API is the front end of the Kubernetes control plane and is how users interact with their Kubernetes cluster. The API (application programming interface) server determines if a request is valid and then processes it. These Kubernetes API server validates and configures data for the api objects which include pods, services, replicationcontrollers, and others.

    Users access the Kubernetes API using kubectl, client libraries, or by making REST requests. Both human users and Kubernetes service accounts can be authorized for API access. When a request reaches the API, it goes through several stages such as
      * Authentication
      * Authorization
      * Admission Control

    Kubernetes API server can actually serve requests on 2 ports:
      * localhost port which is insecure.
      * Secure port which is recommended.

    In order to use `secure port`, we need to set cert with --tls-cert-file and key with --tls-private-key-file flag.

    #### Rationale
    The secure port is used to serve https with authentication and authorization. If you disable it, no https traffic is served and all traffic is served unencrypted.

    #### Audit
    Run the following command on the master node:
    ```
     ps -ef | grep kube-apiserver
    ```
    Verify that the `--secure-port` argument is either not set or is set to an integer value between `1` and `65535`.

    #### Remediation
    Edit the API server pod specification file `/etc/kubernetes/manifests/kube-apiserver.yaml` on the master node  and either remove the `--secure-port` parameter or set it to a different (non-zero) desired port.

    By default, port `6443` is used as the secure port.

    Example:
    ```yaml
      apiVersion: v1
      kind: Pod
      metadata:
        annotations:
          scheduler.alpha.kubernetes.io/critical-pod: ""
        labels:
          component: kube-apiserver
          tier: control-plane
        name: kube-apiserver
        namespace: kube-system
      spec:
        containers:
        - command:
          - kube-apiserver
          - --admission-control=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota
          - --etcd-servers=http://127.0.0.1:2379
          - --authorization-mode=Node,RBAC
          - --admission-control-config-file=admission-config.yaml
          - --enable-admission-plugins=NodeRestriction,NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,Priority,ResourceQuota
    -     - --insecure-bind-address=0.0.0.0
    -     - --insecure-port=8080
    +     - --secure-port=6443
    +     - --tls-cert-file=/etc/kubernetes/pki/apiserver.crt
    +     - --tls-private-key-file=/etc/kubernetes/pki/apiserver.key
          ...
          ...

          image: gcr.io/google_containers/kube-apiserver-amd64:v1.8.0
          livenessProbe:
            failureThreshold: 8
            httpGet:
              host: 127.0.0.1
              path: /healthz
              port: 6443
              scheme: HTTPS
            initialDelaySeconds: 15
            timeoutSeconds: 15
          name: kube-apiserver
          resources:
            requests:
              cpu: 250m
          volumeMounts:
          - mountPath: /etc/kubernetes/pki
            name: k8s-certs
            readOnly: true
          ...
          ...
    ```

    #### Impact
    You need to set the API Server up with the right TLS certificates.

    #### References
    * https://kubernetes.io/docs/admin/kube-apiserver/
    * https://kubernetes.io/docs/concepts/security/controlling-access/
provider: Kubernetes
ruleId: CKV_K8S_89
severity: Medium
sid: ckv-k8s-89
title: "Ensure that the --secure-port argument is not set to 0"
