---
category: Security
checkTool: checkov
checkType: Kubernetes
compliance:
  - CIS
description: |-
    Kubernetes is an open source platform for orchestrating containers. A container is a technology that lets you bundle and isolate applications with their entire runtime environment so that it’s easy to move the contained application between stages (development, production, etc.) and environments (on-premise, public cloud, private cloud, hybrid cloud, or multicloud) while retaining full functionality.

    The Kubernetes API is the front end of the Kubernetes control plane and is how users interact with their Kubernetes cluster. The API (application programming interface) server determines if a request is valid and then processes it. These Kubernetes API server validates and configures data for the api objects which include pods, services, replicationcontrollers, and others.

    Users access the Kubernetes API using kubectl, client libraries, or by making REST requests. Both human users and Kubernetes service accounts can be authorized for API access. When a request reaches the API, it goes through several stages such as
      * Authentication
      * Authorization
      * Admission Control

    In Authentication phase, when the API servers receives a service account token, it validates that token using a separate public/private key pair that was used for signing service account tokens. So we need to specify the API server with the file that contains that key pair.
extra:
  entity: containers
  type: resource
guidelines: |-
    #### Description
    Kubernetes is an open source platform for orchestrating containers. A container is a technology that lets you bundle and isolate applications with their entire runtime environment so that it’s easy to move the contained application between stages (development, production, etc.) and environments (on-premise, public cloud, private cloud, hybrid cloud, or multicloud) while retaining full functionality.

    The Kubernetes API is the front end of the Kubernetes control plane and is how users interact with their Kubernetes cluster. The API (application programming interface) server determines if a request is valid and then processes it. These Kubernetes API server validates and configures data for the api objects which include pods, services, replicationcontrollers, and others.

    Users access the Kubernetes API using kubectl, client libraries, or by making REST requests. Both human users and Kubernetes service accounts can be authorized for API access. When a request reaches the API, it goes through several stages such as
      * Authentication
      * Authorization
      * Admission Control

    In Authentication phase, when the API servers receives a service account token, it validates that token using a separate public/private key pair that was used for signing service account tokens. So we need to specify the API server with the file that contains that key pair.

    #### Rationale
    By default, if no `--service-account-key-file` is specified to the apiserver, it uses the private key from the TLS serving certificate to verify service account tokens. To ensure that the keys for service account tokens could be rotated as needed, a separate public/private key pair should be used for signing service account tokens. Hence, the public key should be specified to the apiserver with `--service-account-key-file`.

    #### Audit
    Run the following command on the master node:
    ```
     ps -ef | grep kube-apiserver
    ```
    Verify that the `--service-account-key-file` argument exists and is set as appropriate.

    #### Remediation
    Edit the API server pod specification file `/etc/kubernetes/manifests/kube-apiserver.yaml` on the master node and set the --service-account-key-file parameter to the public key file for service accounts.
    ```
      --service-account-key-file=<filename>
    ```

    By default, `--service-account-key-file` argument is not set.

    Example:
    ```yaml
      apiVersion: v1
      kind: Pod
      metadata:
        annotations:
          scheduler.alpha.kubernetes.io/critical-pod: ""
        labels:
          component: kube-apiserver
          tier: control-plane
        name: kube-apiserver
        namespace: kube-system
      spec:
        containers:
        - command:
          - kube-apiserver
          - --admission-control=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota
          - --etcd-servers=http://127.0.0.1:2379
          - --authorization-mode=Node,RBAC
          - --admission-control-config-file=admission-config.yaml
          - --enable-admission-plugins=NodeRestriction,NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,Priority,ResourceQuota
          - --secure-port=6443
          - --tls-cert-file=/etc/kubernetes/pki/apiserver.crt
          - --tls-private-key-file=/etc/kubernetes/pki/apiserver.key
          - --audit-log-path=/var/log/apiserver/audit.log
          - --audit-log-maxage=30
          - --audit-log-maxbackup=10
          - --audit-log-maxsize=100
          - --request-timeout=60
          - --service-account-lookup=true
    +     - --service-account-key-file=/etc/kubernetes/pki/sa.pub
          ...
          ...

          image: gcr.io/google_containers/kube-apiserver-amd64:v1.8.0
          livenessProbe:
            failureThreshold: 8
            httpGet:
              host: 127.0.0.1
              path: /healthz
              port: 6443
              scheme: HTTPS
            initialDelaySeconds: 15
            timeoutSeconds: 15
          name: kube-apiserver
          resources:
            requests:
              cpu: 250m
          volumeMounts:
          - mountPath: /etc/kubernetes/pki
            name: k8s-certs
            readOnly: true
          ...
          ...
    ```

    #### Impact
    The corresponding private key must be provided to the controller manager. You would need to securely maintain the key file and rotate the keys based on your organization's key rotation policy.

    #### References
    * https://kubernetes.io/docs/admin/kube-apiserver/
    * https://github.com/kubernetes/kubernetes/issues/24167
provider: Kubernetes
ruleId: CKV_K8S_97
severity: Medium
sid: ckv-k8s-97
title: "Ensure that the --service-account-key-file argument is set as appropriate"
